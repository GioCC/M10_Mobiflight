// ===============================================================================
// ===== Button (base class)
// ===============================================================================

/* 
* This file declares the base class for all ButtonXXX classes.
* ButtonXXX objects receive a set of I/O flags describing the status of its associated input or 'pin'
* (for current status, up/dn transitions etc - see doc) and invokes callback functions accordingly.
* Callbacks are all defined in the derived classes.
*
* 'Tag' and 'Data' attibutes can be of several types (they are unions); currently there is no provision
* to discriminate which of the possible types is used, the caller is responsible for their correct
* interpretation!
*/

// Non-empty constructors:
Button( 
    uint8_t     pin,
    uint8_t     useHWinput,
    const char  *name,
    uint8_t     *mirrorvar=NULL,
    uint8_t     mirrorbit=0
);

Button( 
    uint8_t     pin,
    uint8_t     useHWinput,
    uint16_t    tag,
    uint8_t     *mirrorvar=NULL,
    uint8_t     mirrorbit=0
);

virtual void check(ButtonStatus_t value) { UNUSED(value); }
// Checks the state of the button and triggers events accordingly;
// >>> This method must be (re)defined in the specific button type classes.
// 'value' is either a byte value (for analog inputs)
// or a bit pattern with following meaning (where applicable):
//   Scurr    Current input status
//   Sdn      Input just became active
//   Sup      Input was just released
//   Srpt     A repeat interval just expired
//   Slong    The long press interval just expired
// All flags except Scurr are expected to be set for one call only,
// right after the event occurs.

// Private (protected) vars:
uint8_t         _pin;
uint8_t         _flags;
TagData         _tag;
// TagData         _data;

uint8_t         *srcVar;    // #ifdef SOURCEVAR
uint8_t         *mirrVar;   // #ifdef MIRRORVAR
uint8_t         bitno;      // #ifdef (SOURCEVAR|MIRRORVAR)

// ===============================================================================
// ===== ButtonBas
// ===============================================================================
/* 
* This class is a simplified version of ButtonAdv, stripped of repeat/longpress functions
* to substantially reduce memory footprint.
*
* The ButtonBas reads a value either:
* - directly from a digital I/O pin
* - directly from an analog I/O pin
* - an argument passed to the polling routine,  digital or analog
* and, after processing, invokes callback functions accordingly.
* Analog values are used for multi-position switches (thus are converted to a digital value
* for a specified range); for each position a different ButtonBas object must be defined
* (each with its own range).
* One of the four modes above can be chosen by using the corresponding constructor.
*
* Timings (for debounce, repeat etc) are handled internally.
*
* For uniformity, the polling method always takes a ButtonStatus_t argument, which however 
* is ignored if hardware inputs are used.
*/

// Non-empty constructors:
ButtonBas(  
    uint8_t     pin,
    uint8_t     useHWinput,
    char*       name,
    uint8_t     lthreshold  =0,
    uint8_t     uthreshold  =0,
    uint8_t*    mirrorvar   =NULL,
    uint8_t     mirrorbit   =0
);

ButtonBas(  
    uint8_t     pin,
    uint8_t     useHWinput,
    uint16_t    code,
    uint8_t     lthreshold  =0,
    uint8_t     uthreshold  =0,
    uint8_t*    mirrorvar   =NULL,
    uint8_t     mirrorbit   =0
);

void    check(ButtonStatus_t value);
// Checks the state of the button and triggers events accordingly;
// 'value' is either:
// - an analog value (0..255)
// - for digital values, a bit pattern of type Button::ButtonStatus_t,
//   with following meaning (see also base class):
//      Button::curr    Current input status
//      Button::dn      Input just became active
//      Button::up      Input was just released
//      Button::rpt     A repeat interval just expired
//      Button::long    The long press interval just expired
//   All flags except Button::curr are expected to be only set for the call right after the event occurs.
// If the button is configured for direct HW pin reading, this value is ignored and HW value fetch is performed.
// WARNING (for HW reading only): digital inputs are considered ACTIVE (yielding HIGH) if closed to GND.

void    check(uint8_t *bytevec);
// A variant of 'check()' for digital inputs only (specific to derived class)
// Gets its input source from the passed byte array according to pin#:
// bytevec[0] contains values of pins 1..8 (bits 0..7), bytevec[1] contains pins 9..16 etc
// It is responsibilty of the caller to assure that bytevec[] has a size compatible with the button's pin no.

// Private vars:
static BBcallback  _OnPress;
static BBcallback  _OnRelease;

uint8_t         debounceTime;       // internally in ms
unsigned long   TlastChange;
uint8_t         pressFlag;

uint8_t         lowerAnaThrs;   // internally in 1/256th
uint8_t         upperAnaThrs;   // internally in 1/256th

// ===============================================================================
// ===== ButtonEnc
// ===============================================================================

/*
* The ButtonEnc receives a set of I/O flags describing the status of its associated input or 'pin'
* (for current status, up/dn transitions etc - see doc) and invokes callback functions accordingly.
*/

// Non-empty constructors:
ButtonEnc(  
    uint8_t     index,
    char*       name,
    uint8_t*    mirrorvar   =NULL,
    uint8_t     mirrorbit   =0
);

ButtonEnc(  
    uint8_t     index,
    uint16_t    code,
    uint8_t*    mirrorvar   =NULL,
    uint8_t     mirrorbit   =0
);

void    check(ButtonStatus_t value);
// Checks the state of the button and triggers events accordingly;
// Will be called from the ButtonGroupManager
// 'value' is a bit pattern with following meaning (see base class):
//   Button::curr    Current input status
//   Button::dn      Input just became active
//   Button::up      Input was just released
//   Button::rpt     A repeat interval just expired
//   Button::long    The long press interval just expired
// All flags except Button::curr are expected to be set for one call only,
// right after the event occurs.
// IMPORTANT: Input status is expected to be already debounced.

// Private vars:
static EBcallback _OnPress;
static EBcallback _OnRelease;
static EBcallback _OnLong;

// ===============================================================================
// ===== ButtonAdv
// ===============================================================================

/*
* The ButtonAdv reads a value either:
* - directly from a digital I/O pin
* - directly from an analog I/O pin
* - an argument passed to the polling routine, digital or analog
* and, after processing, invokes callback functions accordingly.
* Analog values are used for multi-position switches (thus are converted to a digital value
* for a specified range); for each position a different ButtonAdv object must be defined (each
* with its own range).
* One of the four modes above can be chosen by using the corresponding constructor.
*
* Timings (for debounce, repeat etc) are handled internally.
*
* There are some peculiarities with respect to other classes in the family:
* - this class can deal with physical inputs directly
* - this class can handle independent timings when using data from a supplied input value;
* - this class can take an analog value supplied as input.
* In the first case, independent timings are mandatory (because no global vector-level timings are available);
* in the second case, the internal implementation of timings may be exploited if several inputs require their
* own different timing parameters.
*
* For uniformity, the polling method always takes a ButtonStatus_t argument, which however is ignored if hardware
* inputs are used.
*/

// Non-empty constructors:
ButtonAdv(  
    uint8_t     in,
    uint8_t     hardware,
    char*       name,
    uint16_t    repeatDelay =0,
    uint16_t    repeatRate  =0,
    uint16_t    longPress   =0,
    uint8_t     lthreshold  =0,  // Threshold values specified in 1/256th (0..255)
    uint8_t     uthreshold  =0,  // Threshold values specified in 1/256th (0..255)
    uint8_t*    mirrorvar   =NULL,
    uint8_t     mirrorbit   =0
);

ButtonAdv(  
    uint8_t     in,
    uint8_t     hardware,
    uint16_t    code,
    uint16_t    repeatDelay =0,
    uint16_t    repeatRate  =0,
    uint16_t    longPress   =0,
    uint8_t     lthreshold  =0,  // Threshold values specified in 1/256th (0..255)
    uint8_t     uthreshold  =0,  // Threshold values specified in 1/256th (0..255)
    uint8_t*    mirrorvar  =NULL,
    uint8_t     mirrorbit   =0
);

void    check(ButtonStatus_t value);
// Checks the state of the button and triggers events accordingly;
// Will be called from the ButtonGroupManager
// 'value' is either:
// - an analog value (0..255)
// - for digital values, a bit pattern of type Button::ButtonStatus_t,
//   with following meaning (see also base class):
//      Button::curr    Current input status
//      Button::dn      Input just became active
//      Button::up      Input was just released
//      Button::rpt     A repeat interval just expired
//      Button::long    The long press interval just expired
//   All flags except Button::curr are expected to be only set for the call right after the event occurs.
// If the button is configured for direct HW pin reading, this value is ignored and HW value fetch is performed.

void    check(uint8_t *bytevec);
// A variant of 'check()' for digital inputs only (specific to derived class)
// Gets its input source from the passed byte array according to pin#:
// bytevec[0] contains values of pins 1..8 (bits 0..7), bytevec[1] contains pins 9..16 etc
// It is responsibilty of the caller to assure that bytevec[] has a size compatible with the button's pin no.
//
// If the button is configured for direct HW pin reading or Analog source, a call to this method has NO EFFECT.

// Private vars:
static BAcallback   _OnPress;
static BAcallback   _OnRelease;
static BAcallback   _OnLong;

uint8_t         debounceTime;       // internally in ms
uint8_t         repeatDelay;        // internally in ms*100; range 100ms..25.5s
uint8_t         repeatRate;         // internally in ms*10; range 10ms..2.55s
uint8_t         longPDelay;         // internally in ms*100; range 100ms..25.5s
unsigned long   TlastChange;
unsigned long   TstartPress;
unsigned long   TlastPress;
uint8_t         longPFlag;

uint8_t         lowerAnaThrs;   // internally in 1/256th
uint8_t         upperAnaThrs;   // internally in 1/256th
uint8_t         hysteresis;     // 0..255

// ===============================================================================
// ===== ButtonGrp
// ===============================================================================

/*
* This file defines the ButtonGrp class.
* The ButtonGrp receives a set of I/O flags describing the status of its associated input or 'pin'
* (for current status, up/dn transitions etc - see doc) and invokes callback functions accordingly.
*/

// NOTE: Currently, a "long press" triggers both the "Press" and the "LongPress" events;
// this may or may not be as intended.
// A possible improvement: if a "LongPress" callback is used, the "Press" event is handled differently
// so as to match a "ShortPress" (which is actually activated on release before the LongPress time).
// Better: a mode flag tells whether to use two available callbacks either as "Press/Release" or "Short/Long press"
// (Repeat would be feasible in both modes).

// Non-empty constructors:
ButtonGrp(  
    uint8_t     pin,
    char*       name,
    uint8_t     rptEnabled   = 0,
    uint8_t*    mirrorvar   = NULL,
    uint8_t     mirrorbit   = 0
);

ButtonGrp(  
    uint8_t     pin,
    uint16_t    code,
    uint8_t     rptEnabled   = 0,
    uint8_t*    mirrorvar   = NULL,
    uint8_t     mirrorbit   = 0
);

void    check(ButtonStatus_t value);
// Checks the state of the button and triggers events accordingly;
// Will be called from the ButtonGroupManager
// 'value' is a bit pattern with following meaning (see base class):
//   Button::curr    Current input status
//   Button::dn      Input just became active
//   Button::up      Input was just released
//   Button::rpt     A repeat interval just expired
//   Button::long    The long press interval just expired
// All flags except Button::curr are expected to be set for one call only,
// right after the event occurs.

// Private vars:
static GBcallback _OnPress;
static GBcallback _OnRelease;
static GBcallback _OnLong;


// ===============================================================================
// ===== ButtonAna
// ===============================================================================

/*
* The ButtonAna object receives an analog value (unsigned 8-bit integer) describing the status
* of the associated input or 'pins'; if the value falls between the defined thresholds (with
* hysteresis), then the "equivalent" digital input is considered active, and callback functions are invoked
* accordingly.
* For current status, up/dn transitions etc see docs.
*/

// Non-empty constructors:
ButtonAna(  
    uint8_t     pin,
    char*       name,
    uint8_t     lthreshold =128,
    uint8_t     uthreshold =255,
    uint16_t    repeatDelay=0,
    uint16_t    repeatRate =0,
    uint8_t*    mirrorvar  =NULL,
    uint8_t     mirrorbit  =0
);

ButtonAna(  
    uint8_t     pin,
    uint16_t    code,
    uint8_t     lthreshold =128,
    uint8_t     uthreshold =255,
    uint16_t    repeatDelay=0,
    uint16_t    repeatRate =0,
    uint8_t*    mirrorvar  =NULL,
    uint8_t     mirrorbit  =0
);

void check(ButtonStatus_t value);
// Checks the state of the button and triggers events accordingly;
// Will be called from the ButtonGroupManager

// Private vars:
static ABcallback   _OnPress;
static ABcallback   _OnRelease;

uint8_t         debounceTime;       // internally in ms
uint8_t         repeatDelay;        // internally in ms*100; range 100ms..25.5s
uint8_t         repeatRate;         // internally in ms*10; range 10ms..2.55s
unsigned long   TlastChange;
unsigned long   TstartPress;
unsigned long   TlastPress;

uint8_t         lowerAnaThrs;   // 0..255
uint8_t         upperAnaThrs;   // 0..255
uint8_t         hysteresis;     // 0..255

